#!/usr/bin/env python
'''
Author: Pu Zhichen
Date: 2021-04-27 16:37:46
LastEditTime: 2021-07-02 10:28:47
LastEditors: Pu Zhichen
Description: 
    Get the symmetry adapted basis.
FilePath: \pyMC\mole_sym\orbital_symm_utils.py

 May the force be with you!
'''


import numpy
import time
from pyscf import __config__
from scipy.spatial.transform import Rotation as R
import scipy
from pyMC.lib import group_info
from pyMC.tools import group_proj

def symm_adapted_basis_double_group(mol, molsingle, gpname):
    """This subroutine is embeded in mole_symm.build(), which is aimming at 
    generates symmetry-adapted basis.

    Args:
        mol (Mole class): The multi-atom molecule with double group symmetry
        molsingle (Mole class): The single-atom which is used in atom rotation.
        gpname (str): The name of the group. Defaults to

    Raises:
        NotImplementedError: Only double group for D3 and D5 is implemented now.
        RuntimeError: Linear-dependent
        RuntimeError: Insufficient bases

    Returns:
        so (list): A list of numpy arrays, which saves the spin adapted basis in the order of 
            irrep_id
        irrep_id (list): Irreducible id.
        id_2_irrep (dictionary): Mapping the irrep id to the irrep name.
    """
    
    nao = mol.nao
    naou = molsingle.nao
    threshold = mol.symm_threshold
    if mol.ovlp is None:
        mol.ovlp = mol.get_ovlp()
    else:
        Sblock = mol.ovlp
    
    S = numpy.asarray(scipy.linalg.block_diag(Sblock,Sblock))
    
    # Cbase is the initial mo_coeff to generate the symmetry-adapted basis.
    # Cbase is generated by setting only one molecule orbitals to identity matrix.
    # Which means each orbital is consist of only one basis.
    # The initial mo_coeff is somehow arbitary, in this program, choosing alpha_alpha and beta_beta
    Cbase = numpy.zeros((nao*2,nao*2),dtype=numpy.complex128)
    ones = numpy.eye(naou)
    Cbase[:naou,:naou] = ones
    Cbase[nao:naou+nao,nao:naou+nao] = ones
    so = []
    irrep_id = []
    
    # Prepare some group informations
    if gpname not in group_info.GROUP:
        raise NotImplementedError(gpname + ' is not implemented')
    irrep_2_id = group_info.IRREP_ID_TABLE_DOUBLE[gpname]
    id_2_irrep = dict( [val,key] for key,val in irrep_2_id.items())
    nirrep = id_2_irrep.__len__()
    
    # Project the basis to symmetry-adapted basis
    for irrep in range(nirrep):
        C_so = group_proj.project_2_SO(molsingle, mol, Cbase,
                            group=gpname, operator='MATRIX', rep = id_2_irrep[irrep])
        norm = numpy.linalg.norm(C_so,axis=0)
        orbital_id = numpy.where(norm>=threshold)[0]
        # * It should be normalise !
        C_so_irrep = C_so[:,orbital_id]/norm[orbital_id]
        if C_so_irrep.shape[-1] != 0:
            so.append(C_so_irrep)
            irrep_id.append(irrep)
    
    # Remove the linear-dependent part
    nso = 0
    for irrep in range(so.__len__()):
        ovlp_matrix = so[irrep].conj().T@S@so[irrep]
        svalue,ctemp = numpy.linalg.eigh(ovlp_matrix)
        offset = numpy.where(svalue > 1.0E-10)[0]
        so[irrep] = so[irrep]@ctemp[:,offset]
        nso+= so[irrep].shape[-1]
    
    # Check whether get all the closed basis which nso == nao
    if nso < nao*2:
        raise RuntimeError("Not enough symmetry-adapted basis, please recheck the initial \
                           guess! ")
    elif nso == nao*2:
        print("Get the symmetry adapted basis!")
    elif nso > nao*2:
        raise RuntimeError("Linear-dependence still exists!")
        
    return so, irrep_id, id_2_irrep

def generate_equal_basis(mol, molsingle, gpname, so, equal_table):
    
    # get the matrix representation for each multi-dimensional irreps.
    shift_matrix_rep = {}
    for i in equal_table:
        shift_matrix_rep[i] = group_info.EQUAL_BASIS_SHIFT[gpname][i]

    for ipair in equal_table:
        nbasis = equal_table[ipair].__len__()
        for iorbital in range(1,nbasis):
            so[equal_table[ipair][iorbital]] = group_proj.\
                project_2_equal_basis(molsingle, mol, so[equal_table[ipair][0]],\
                    shift_matrix_rep[ipair][iorbital-1], nbasis, group = gpname)
                
    return so
        
    
    # using the first basis to generate other basis.
    
    
    
def symm_adapted_basis_double_group_dirac(mol, molsingle, gpname, S):
    """This subroutine is embeded in mole_symm.build(), which is aimming at 
    generates symmetry-adapted basis for spinors, which will be used in Dirac4c calculations.

    Args:
        mol (Mole class): The multi-atom molecule with double group symmetry
        molsingle (Mole class): The single-atom which is used in atom rotation.
        gpname (str): The name of the group. Defaults to

    Raises:
        NotImplementedError: Only double group for D3 and D5 is implemented now.
        RuntimeError: Linear-dependent
        RuntimeError: Insufficient bases

    Returns:
        so (list): A list of numpy arrays, which saves the spin adapted basis in the order of 
            irrep_id
        irrep_id (list): Irreducible id.
        id_2_irrep (dictionary): Mapping the irrep id to the irrep name.
    """
    nao2c = mol.nao_2c()
    naou2c = molsingle.nao_2c()
    threshold = 1.0E-8
    if mol.ovlp is None:
        raise ValueError("S matrix should be given.")
    
    # Cbase is the initial mo_coeff to generate the symmetry-adapted basis.
    # Cbase is generated by setting only one molecule orbitals to identity matrix.
    # Which means each orbital is consist of only one basis.
    # Choosing LL and SS parts.
    Cbase = numpy.zeros((nao2c*2,nao2c*2),dtype=numpy.complex128) # (nao*2,nao*2) for L and S
    ones = numpy.eye(naou2c)
    Cbase[:naou2c,:naou2c] = ones
    Cbase[nao2c:naou2c+nao2c,nao2c:naou2c+nao2c] = ones
    so = []
    irrep_id = []
    
    # Prepare some group informations
    if gpname not in group_info.GROUP:
        raise NotImplementedError(gpname + ' is not implemented')
    irrep_2_id = group_info.IRREP_ID_TABLE_DOUBLE[gpname]
    id_2_irrep = dict( [val,key] for key,val in irrep_2_id.items())
    nirrep = id_2_irrep.__len__()
    
    # Project the basis to symmetry-adapted basis
    for irrep in range(nirrep):
        C_so = group_proj.project_2_SO(molsingle, mol, Cbase,
                            group=gpname, operator='MATRIX', rep = id_2_irrep[irrep])
        norm = numpy.linalg.norm(C_so,axis=0)
        orbital_id = numpy.where(norm>=threshold)[0]
        # * It should be normalise !
        C_so_irrep = C_so[:,orbital_id]/norm[orbital_id]
        if C_so_irrep.shape[-1] != 0:
            so.append(C_so_irrep)
            irrep_id.append(irrep)
    # Remove the linear-dependent part
    nso = 0
    for irrep in range(so.__len__()):
        ovlp_matrix = so[irrep].conj().T@S@so[irrep]
        svalue = numpy.linalg.svd(ovlp_matrix)[1]
        offset = numpy.where(svalue > 1.0E-10)[0]
        so[irrep] = so[irrep][:,offset]
        nso+= so[irrep].shape[-1]
    
    # Check whether get all the closed basis which nso == nao
    if nso < nao2c*2:
        raise RuntimeError("Not enough symmetry-adapted basis, please recheck the initial \
                           guess! ")
    elif nso == nao2c*2:
        print("Get the symmetry adapted basis!")
    elif nso > nao2c*2:
        raise RuntimeError("Linear-dependence still exists!")
        
    return so, irrep_id, id_2_irrep    


def symm_adapted_basis_double_group_dirac_spinor(mol, molsingle, gpname, S):
    """This subroutine is embeded in mole_symm.build(), which is aimming at 
    generates symmetry-adapted basis for spinors, which will be used in Dirac4c calculations.

    Args:
        mol (Mole class): The multi-atom molecule with double group symmetry
        molsingle (Mole class): The single-atom which is used in atom rotation.
        gpname (str): The name of the group. Defaults to

    Raises:
        NotImplementedError: Only double group for D3 and D5 is implemented now.
        RuntimeError: Linear-dependent
        RuntimeError: Insufficient bases

    Returns:
        so (list): A list of numpy arrays, which saves the spin adapted basis in the order of 
            irrep_id
        irrep_id (list): Irreducible id.
        id_2_irrep (dictionary): Mapping the irrep id to the irrep name.
    """
    nao2c = mol.nao_2c()
    naou2c = molsingle.nao_2c()
    threshold = 1.0E-8
    if mol.ovlp is None:
        raise ValueError("S matrix should be given.")
    
    # Cbase is the initial mo_coeff to generate the symmetry-adapted basis.
    # Cbase is generated by setting only one molecule orbitals to identity matrix.
    # Which means each orbital is consist of only one basis.
    # Choosing LL and SS parts.
    Cbase = numpy.zeros((nao2c*2,nao2c*2),dtype=numpy.complex128) # (nao*2,nao*2) for L and S
    ones = numpy.eye(naou2c)
    Cbase[naou2c:naou2c*2,naou2c:naou2c*2] = ones
    Cbase[nao2c+naou2c:naou2c*2+nao2c,nao2c+naou2c:naou2c*2+nao2c] = ones
    so = []
    irrep_id = []
    
    # Prepare some group informations
    if gpname not in group_info.GROUP:
        raise NotImplementedError(gpname + ' is not implemented')
    irrep_2_id = group_info.IRREP_ID_TABLE_DOUBLE[gpname]
    id_2_irrep = dict( [val,key] for key,val in irrep_2_id.items())
    nirrep = id_2_irrep.__len__()

    # Project the basis to symmetry-adapted basis
    for irrep in range(nirrep):
        C_so = group_proj.project_2_SO(molsingle, mol, Cbase,
                            group=gpname, operator='MATRIX', rep = id_2_irrep[irrep])
        norm = numpy.linalg.norm(C_so,axis=0)
        orbital_id = numpy.where(norm>=0.001)[0]
        # * It should be normalise !
        C_so_irrep = C_so[:,orbital_id]/norm[orbital_id]
        if C_so_irrep.shape[-1] != 0:
            so.append(C_so_irrep)
            irrep_id.append(irrep)
    # Remove the linear-dependent part
    nso = 0
    for irrep in range(so.__len__()):
        ovlp_matrix = so[irrep].conj().T@S@so[irrep]
        svalue,ctemp = numpy.linalg.eigh(ovlp_matrix)
        offset = numpy.where(svalue > 1.0E-10)[0]
        so[irrep] = so[irrep]@ctemp[:,offset]
        nso+= so[irrep].shape[-1]
    
    # for irrep in range(so.__len__()):
    #     nmo = so[irrep].shape[-1]
    #     tmp = (so[irrep][:nao2c,:nmo//2] + so[irrep][nao2c:,nmo//2:])*0.5
    #     so[irrep][:nao2c,:nmo//2] = tmp
    #     so[irrep][nao2c:,nmo//2:] = tmp
    
    # Check whether get all the closed basis which nso == nao
    if nso < nao2c*2:
        raise RuntimeError("Not enough symmetry-adapted basis, please recheck the initial \
                           guess! ")
    elif nso == nao2c*2:
        print("Get the symmetry adapted basis!")
    elif nso > nao2c*2:
        raise RuntimeError("Linear-dependence still exists!")
        
    return so, irrep_id, id_2_irrep    


    
    
        
    